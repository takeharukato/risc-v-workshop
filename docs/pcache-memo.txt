[1] データ構造

/*
 * ページキャッシュの状態
 */
#define	PCACHE_INVALID           (0x0)    /**< 無効なキャッシュ                         */
#define	PCACHE_BUSY              (0x1)    /**< ページキャッシュがロックされている       */
#define	PCACHE_CLEAN             (0x2)    /**< ディスクとキャッシュの内容が一致している */
#define	PCACHE_DIRTY             (0x4)    /**< ページキャッシュの方がディスクより新しい */

/*
 * ページキャッシュプールの状態
 */
#define	PCPOOL_DORMANT           (0x0)    /**< 無効なページキャッシュプール             */
#define	PCPOOL_CREATED           (0x1)    /**< 有効なページキャッシュプール             */
#define	PCPOOL_DELETE            (0x2)    /**< 削除予約されている                       */

typedef uint32_t      vfs_pcache_state;   /**< ページキャッシュの状態                   */
typedef uint32_t vfs_pcache_pool_state; /**< ページキャッシュプールの状態 */

/**
   ページキャッシュ
 */
typedef struct _vfs_page_cache{
	/** ページキャッシュデータ構造更新ロック */
	spinlock                         pc_lock;
	/** 排他用ロック(状態/ページ更新用)      */
	struct _mutex                     pc_mtx;
	/** 参照カウンタ                         */
	refcounter                       pc_refs;
	/** ページキャッシュプールへのリンク     */
	struct _page_cache_pool      *pc_pcplink;
	/** バッファの状態                       */
	pcache_state                    pc_state;
	/** パディング                           */
	uint32_t                            pad1;
	/** ページバッファ待ちキュー             */
	struct _wque_waitqueue        pc_waiters;
	/** ブロックデバイス中オフセットをキーとした検索用SPLAY木エントリ                   */
	SPLAY_ENTRY(_vfs_page_cache)  pc_dev_ent;
	/** ファイル中オフセットをキーとした検索用SPLAY木エントリ                           */
	SPLAY_ENTRY(_vfs_page_cache) pc_file_ent;
	/** LRUリストのエントリ                  */
	struct _list                 pc_lru_link;
	/** ファイル中でのオフセットアドレス (単位:バイト)                                  */
	off_t                     pc_file_offset;
	/** ブロックデバイス中でのオフセットアドレス (単位:バイト)                          */
	off_t                     pc_bdev_offset;
	/** ページフレーム情報                   */
	struct _page_frame                *pc_pf;
	/** ページキャッシュデータへのポインタ   */
	void                            *pc_data;
}vfs_page_cache;

/**
   ページキャッシュプール
 */
typedef struct _vfs_page_cache_pool{
	/** 排他用ロック(キュー更新用) */
	struct _mutex                                    pcp_mtx;
	/** 参照カウンタ               */
	refcounter                                      pcp_refs;
	/** ページキャッシュプールの状態 */
        vfs_pcache_pool_state                          pcp_state;
	/** 二次記憶デバイスID         */
	dev_id                                         pcp_bdevid;
	/**  ページサイズ              */
	size_t                                         pcp_pgsiz;
	/**  ブロックデバイスページキャッシュツリー    */
	SPLAY_HEAD(_pcache_bdev_tree, _page_cache)  pcp_dev_head;
	/**  ファイルページキャッシュツリー    */
	SPLAY_HEAD(_pcache_file_tree, _page_cache) pcp_file_head;
	/**  LRUキャッシュ (二次記憶との一貫性がとれているページ)     */
	struct _queue                              pcp_clean_lru;
	/**  LRUキャッシュ (二次記憶よりキャッシュの方が新しいページ) */
	struct _queue                              pcp_dirty_lru;
}vfs_page_cache_pool;

/**
   ページキャッシュプールDB
 */
typedef struct _vfs_page_cache_pool_db{
	/** ページキャッシュプールDBのロック */
	spinlock                         lock;
	/** ページキャッシュプールDB         */
	RB_HEAD(_page_cache_pool_tree, _page_cache_pool) head;
}vfs_page_cache_pool_db;

/**
   ページキャッシュプールDB初期化子
   @param[in] _pcpdb ページキャッシュプールDBのアドレス
 */
#define __PCPDB_INITIALIZER(_pcpdb) {		                            \
	.lock = __SPINLOCK_INITIALIZER,		                            \
	.head  = RB_INITIALIZER(&((_pcpdb)->head)),		            \
	}

1.2. 参照管理
1.2.1. ページキャッシュ
     実行中のスレッドのほかにファイルページキャッシュツリー,
     ブロックデバイスページキャッシュツリー, ページキャッシュプール内のLRUのいずれかから
     参照される
     (実行中のスレッド/関数以外の参照数は, 仮想FSのページキャッシュで2,
      実FSのページキャッシュで3になる)

     I/O操作はインデクス木につないだ状態で, BUSYビットで排他する

     BUSYビットに設定する際に「LRUキューからページキャッシュを取り外す」ことで
     処理を単純化する.
     LRU中のページに対する操作は,
        1) DIRTYなページを2次記憶に書き戻してCLEANに遷移する
	2) CLEANなページを解放する
     の2つであるので, いずれのケースにおいても, 他のスレッドがページをBUSY(使用中)
     設定している間は行えない(ブロックデバイスに書き込むまでページの内容が
     書き換わらないことをread/write操作としては保証する必要があるのと,
     使用中のページを解放できない).
     したがって, BUSYビットをセットした時点でLRUから外して, LRU中ページに対する
     操作の対象にならないようにしておく。
     (*) 実際には, メモリマップドI/O(msync)やpage_flushスレッド中でBUSYビットを
     待ち合わせることができるのでロックの単純化程度の意味しかないが


     v-nodeのファイルページキャッシュツリーからページを取り外した際
     (v-node破棄やshrink契機でページを取り外す際)にページキャッシュの参照を落とす

     (shrink契機で)ブロックデバイスキャッシュからページを取り外した際に参照を落とす
     (この時,
     ページキャッシュプールのLRUから外した際に参照を落とし, 追加した際に加算する

     ページキャッシュの参照が0になるのは, ファイルページキャッシュツリーからページを
     取り外して抜ける場合か, ブロックデバイスキャッシュからページを取り外した際で
     ページキャッシュの参照が0になったら, ページキャッシュプールの参照を減算する

     初期化時は,
      a) ブロックデバイスキャッシュからのページキャッシュ検索時に生成した場合,
         ブロックデバイスページキャッシュツリー分の参照
      b) v-nodeのページキャッシュ検索時に生成した場合,
         ファイルページキャッシュツリー分の参照
     の「いずれか一つ」として1が加算されている.

     a), b)のいずれかの生成処理でツリーに登録した際にページキャッシュプールの参照を加算する

     ページキャッシュプールからページキャシュへの参照は各ツリーへの登録やキューへの追加
     削除を単位として, 加算・減算されるのに対し, ページキャッシュからプールへの参照は,
     キャッシュツリー単位ではなく, ページキャッシュプール単位で行う。

     ページキャッシュ内のすべてのツリー、LRUから取り外された場合
     (ページキャッシュの参照が0になる際)にのみ, ページキャッシュプールの参照を減算する

1.2.2. ページキャッシュプール
     ページキャッシュプール生成時に参照数は1(ページキャッシュプールDBからの参照分)となる。
     実行中のスレッドからの参照のほかに, ページキャッシュプール中のページキャッシュからの
     参照(上記)が含まれる

     ページキャッシュプールの破棄の際に参照数を落とす(2重破棄を避けるためにフラグを用意する)


[2] インターフェース

2.. ページキャッシュ割り当て・初期化 (内部関数)

2.. ページキャッシュ解放 (内部関数)

2.. ページキャッシュ参照加算 (vfs内部関数)

2.. ページキャッシュ参照減算 (vfs内部関数)

2.. ページキャッシュの状態をclean(二次記憶との一貫性がとれた状態)に設定する (内部関数)

2.. ページキャッシュの状態をdirty(二次記憶よりキャッシュの方が新しい状態)に設定する(内部関数)

2.. ページキャッシュDBへのブロックデバイスキャッシュの登録
2.. ページキャッシュDBからのブロックデバイスキャッシュの登録抹消
2.. ページキャッシュDBからブロックデバイスキャッシュの検索・参照取得

2.. ブロックデバイスキャッシュへのページキャッシュ登録
2.. ブロックデバイスキャッシュからのページキャッシュ登録抹消
2.. ブロックデバイスキャッシュからのページキャッシュ検索

2.. ブロックデバイスキャッシュ中のページキャッシュに二次記憶の内容を読みだし
2.. ブロックデバイスキャッシュ中のページキャッシュを二次記憶へ書き出し

2.. v-nodeのページキャッシュツリーへの登録
2.. v-nodeのページキャッシュツリーからの登録抹消
2.. v-nodeのページキャッシュツリーからの検索

2.. v-node初期化時のページキャッシュツリーの初期化
2.. v-node解放処理のページキャッシュ書き出し

vfsレイヤでのread/writeシステムコールページ単位でのI/O処理:
(1) ページをv-nodeのページキャッシュツリーから検索する
(2) v-nodeのページキャッシュツリーからページが見つからなければ,
    ページキャッシュを割り当て, ページの内容をクリアする
    (ページの状態はInvalid)
(3) ページの状態がDirtyでなく, かつ, validでなく, かつ、
    マウントされているファイルシステム(疑似ファイルシステムでない)または
    v-nodeのマウント情報のdevidが無効デバイスでなければ、以下の(a)-(b)を実施する
    (a) ファイルシステムに依頼して, ファイル内オフセットを指定して、
        ページに二次記憶のブロックの割り当てを依頼する(fsオペレーション)
    (b) ファイルシステムのread_pageオペレーションが定義されていなければ
        ページリードの項目に記載している内容を実施する
        (read_page_from_block_device関数として定義する)
    (c) ページの状態をValid(clean)にする

(4) ページの状態がdirtyかvalidであることを確認する
    (dirty|valid)との論理積が0でなく、かつ、(dirty|valid)でないことを確認する

(5) ページをv-nodeのページキャッシュツリーに登録する
(6) devidが無効デバイスでなければ, ページをブロックデバイスキャッシュに登録する
(6) writeの場合は, ファイルシステムのwrite_pageオペレーションを呼び出す
(7) ページがBUSYでないことを確認
(8) ページがDIRTYの場合は, DIRTY LRUの, VALIDの場合は, CLEAN LRUの末尾に
    ページキャッシュを追加する
(6) (1)で得たページキャッシュへの参照を解放する

2.. ページに二次記憶のブロックを割り当てる (fsオペレーション)
    (1) i-nodeのブロックマップ情報に従ってマップ先ブロックを算出する
    (2) そのブロックのページアドレス(デバイスの先頭からページ単位で区切った際の
        連番)を算出する
    (3) (2)で得た値をページキャッシュのpc_bdev_offsetに設定する

2.. ページリード (fsオペレーション)
    (a) ページに対するリクエストキューを作成する
    (b) リクエストキューにページへの読み込み/書き込み種別と
        ページキャッシュの組からなるリクエストエントリを追加する
    (c) ブロックの内容をページに読み込むようブロックデバイスに要求する
        将来的には非同期リクエストを発行して, リクエストキューで休眠する
    デバイスドライバは以下のi), ii)を実行する
        i) ドライバはリクエストキュー中のリクエストを取り出して、
           ページをBUSY(ロック)状態にする
       ii)  デバイスへのI/Oリクエストを
	   ページをブロックに分割して、ブロック単位で発行する。
  	   ページの途中でエラーになったら対象のリクエストにエラーマークを設定する
       iii) ページのBUSY(ロック)状態を解除する
	iv) リクエストの最後までページを処理する
    	   (*) 非同期I/Oを想定して、リクエストエントリ, リクエストキューは動的に
	       メモリ獲得する。
        v) リクエストキュー中のをすべてのリクエストエントリを処理し終わったら,
           リクエストキューで休眠しているプロセスを起床する
    (d) リクエストキューを順番に取り出し、完了したリクエストエントリを解放
    (e) リクエストキューを解放
    (f) (d) でエラーリクエストがあった場合は, エラー復帰する

2.. ページライト (fsオペレーション)
2.. ページを二次記憶に書き戻す前準備を行う (fsオペレーション)
- ジャーナリングなど
