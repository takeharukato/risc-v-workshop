[1] データ構造

/*
 * ページキャッシュの状態
 */
#define	PCACHE_INVALID           (0x0)    /**< 無効なキャッシュ                         */
#define	PCACHE_BUSY              (0x1)    /**< ページキャッシュがロックされている       */
#define	PCACHE_CLEAN             (0x2)    /**< ディスクとキャッシュの内容が一致している */
#define	PCACHE_DIRTY             (0x4)    /**< ページキャッシュの方がディスクより新しい */

/*
 * ページキャッシュプールの状態
 */
#define	PCPOOL_DORMANT           (0x0)    /**< 無効なページキャッシュプール             */
#define	PCPOOL_CREATED           (0x1)    /**< 有効なページキャッシュプール             */
#define	PCPOOL_DELETE            (0x2)    /**< 削除予約されている                       */

typedef uint32_t      vfs_pcache_state;   /**< ページキャッシュの状態                   */
typedef uint32_t vfs_pcache_pool_state; /**< ページキャッシュプールの状態 */

/**
   ページキャッシュ
 */
typedef struct _vfs_page_cache{
	/** ページキャッシュデータ構造更新ロック */
	spinlock                         pc_lock;
	/** 排他用ロック(状態/ページ更新用)      */
	struct _mutex                     pc_mtx;
	/** 参照カウンタ                         */
	refcounter                       pc_refs;
	/** ページキャッシュプールへのリンク     */
	struct _page_cache_pool      *pc_pcplink;
	/** バッファの状態                       */
	pcache_state                    pc_state;
	/** パディング                           */
	uint32_t                            pad1;
	/** ページバッファ待ちキュー             */
	struct _wque_waitqueue        pc_waiters;
	/** ファイル/ブロックデバイス中のオフセットをキーとした検索用RB木エントリ        */
	RB_ENTRY(_vfs_page_cache)         pc_ent;
	/** ファイル中でのオフセットアドレス (単位:バイト)                               */
	off_t                          pc_offset;
	/** LRUリストのエントリ                                                          */
	struct _list                 pc_lru_link;
	/** ページフレーム情報                   */
	struct _page_frame                *pc_pf;
	/** ページキャッシュデータへのポインタ   */
	void                            *pc_data;
}vfs_page_cache;

/**
   ページキャッシュプール
 */
typedef struct _vfs_page_cache_pool{
	/** 排他用ロック(キュー更新用) */
	struct _mutex                                    pcp_mtx;
	/** 参照カウンタ               */
	refcounter                                      pcp_refs;
	/** ページキャッシュプールの状態 */
        vfs_pcache_pool_state                          pcp_state;
	/** 二次記憶デバイスID         */
	dev_id                                        pcp_bdevid;
	/** ファイルのv-node           */
	struct _vnode                                 *pcp_vnode;
	/**  ページサイズ              */
	size_t                                         pcp_pgsiz;
	/**  ページキャッシュツリー    */
	RB_HEAD(_pcache_tree, _vfs_page_cache)          pcp_head;
	/**  LRUキャッシュ (二次記憶との一貫性がとれているページ)     */
	struct _queue                              pcp_clean_lru;
	/**  LRUキャッシュ (二次記憶よりキャッシュの方が新しいページ) */
	struct _queue                              pcp_dirty_lru;
}vfs_page_cache_pool;

/**
   ページキャッシュプールDB(デバイスIDをキーにデバイスのページキャッシュプールを検索する)
 */
typedef struct _vfs_page_cache_pool_db{
	/** ページキャッシュプールDBのロック */
	spinlock                         lock;
	/** ページキャッシュプールDB         */
	RB_HEAD(_page_cache_pool_tree, _page_cache_pool) head;
}vfs_page_cache_pool_db;

/**
   ページキャッシュプールDB初期化子
   @param[in] _pcpdb ページキャッシュプールDBのアドレス
 */
#define __PCPDB_INITIALIZER(_pcpdb) {		                            \
	.lock = __SPINLOCK_INITIALIZER,		                            \
	.head  = RB_INITIALIZER(&((_pcpdb)->head)),		            \
	}


1.2. 参照管理
1.2.1. ページキャッシュ
     実行中のスレッドのほかにv-nodeのファイルページキャッシュツリー,
     ブロックデバイスページキャッシュツリー, ページキャッシュプール内のLRUのいずれかから
     参照される
     (実行中のスレッド/関数以外の参照数は, 仮想FSのページキャッシュで2,
      実FSのページキャッシュで3になる)

     I/O操作はインデクス木につないだ状態で, BUSYビットで排他する

     BUSYビットに設定する際に「LRUキューからページキャッシュを取り外す」ことで
     処理を単純化する.
     LRU中のページに対する操作は,
        1) DIRTYなページを2次記憶に書き戻してCLEANに遷移する
	2) CLEANなページを解放する
     の2つであるので, いずれのケースにおいても, 他のスレッドがページをBUSY(使用中)
     設定している間は行えない(ブロックデバイスに書き込むまでページの内容が
     書き換わらないことをread/write操作としては保証する必要があるのと,
     使用中のページを解放できない).

     したがって, BUSYビットをセットした時点でLRUから外して, LRU中ページに対する
     操作の対象にならないようにしておく。
     (*) 実際には, メモリマップドI/O(msync)やpage_flushスレッド中でもBUSYビットを
     待ち合わせることができるのでロックの単純化程度の意味しかないが


     v-nodeのファイルページキャッシュツリーからページを取り外した際
     (v-node破棄やshrink契機でページを取り外す際)にページキャッシュの参照を落とす

     (shrink契機で)ブロックデバイスキャッシュからページを取り外した際に参照を落とす
     この時, ページキャッシュプールのLRUから外した際に参照を落とし, 追加した際に加算する

     ページキャッシュの参照が0になるのは, ファイルページキャッシュツリーからページを
     取り外して抜ける場合か, ブロックデバイスキャッシュからページを取り外した場合である.
     ページキャッシュの参照が0になったら, ページキャッシュプールの参照を減算する.

     初期化時は,
      a) ブロックデバイスキャッシュからのページキャッシュ検索時に生成した場合,
         ブロックデバイスページキャッシュツリー分の参照
      b) v-nodeのページキャッシュ検索時に生成した場合,
         ファイルページキャッシュツリー分の参照
     の「いずれか一つ」として1が加算されている.

     a), b)のいずれかの生成処理でツリーに登録した際にページキャッシュプールの参照を加算する

     ページキャッシュプールからページキャシュへの参照は各ツリーへの登録やキューへの追加
     削除を単位として, 加算・減算されるのに対し, ページキャッシュからプールへの参照は,
     キャッシュツリー単位ではなく, ページキャッシュプール単位で行う。

     ページキャッシュ内のすべてのツリー、LRUから取り外された場合
     (ページキャッシュの参照が0になる際)にのみ, ページキャッシュプールの参照を減算する

1.2.2. ページキャッシュプール
     ページキャッシュプール生成時に参照数は1
     (ページキャッシュプールDBまたはv-nodeからの参照分)となる。
     実行中のスレッドからの参照のほかに, ページキャッシュプール中のページキャッシュからの
     参照(上記)が含まれる

     ページキャッシュプールの破棄の際に参照数を落とす(2重破棄を避けるためにフラグを用意する)

     ページキャッシュプールからv-nodeを指すポインタがあるがこれによってポイントされている場合
     でもv-nodeの参照数はあげてはならない(v-nodeは, ページキャッシュプールを介してページ
     キャッシュを操作するので内部のページキャッシュの状態に依存しない)
     ページキャッシュプールをv-nodeから参照する際にv-nodeからページキャッシュプールへの
     参照をあげ, v-node解放時にページキャッシュプールからv-nodeを指すポインタをNULLにし
     ページキャッシュプール中のページキャッシュツリーからページキャッシュを外して,
     ページキャッシュの参照を落とす

     ページキャッシュプール中のページキャッシュツリーからページキャッシュを取り外したら
     ページキャッシュプールへの参照を落とす

[2] インターフェース

2.. ページキャッシュの初期化 (内部関数)
	スピンロックを初期化
	排他用ロック(mutex)を初期化
	参照カウンタを初期化
	ページキャッシュプールへのリンクを初期化
	ページキャッシュの状態を無効(Invalid)に設定
	ページバッファ待ちキューを初期化
	LRUリストのエントリを初期化
	ファイル中でのオフセットアドレスを初期化
	ブロックデバイス中でのオフセットアドレスを初期化
	ページフレーム情報を初期化
	ページキャッシュデータへのポインタを初期化

2.. ファイルオフセット指定でのページキャッシュ検索・獲得 (内部関数)
    引数にv-node, ファイルオフセットを指定して検索し,
    見つからなかった場合は, キャッシュを新規に割り当てる
    見つかったページキャッシュに対する参照を加算してページキャッシュのアドレスを返却する

    1) v-nodeのmutexを獲得する
       獲得に失敗したらエラー復帰する
    2) v-nodeのファイルページキャッシュツリーからページを検索する
    3) ページが見つからなかった場合は,
       a) slabからページキャッシュを割り当てる
       b) v-nodeがブロックデバイスにマウントされていた場合は
          vfsオペレーションを呼び出してページにブロックを割り当てる
	  ブロックの割り当てに失敗したらmutexを解放して, ページキャッシュを解放する
	  エラー復帰ルートに飛ぶ
	  (ページキャッシュの参照カウンタを減算する)
       c) ページキャッシュをv-nodeのファイルページキャッシュツリーに登録する
          登録に失敗しないはず
     4) v-nodeのmutexを解放する
     5) 実行中のスレッドからの操作用にページキャッシュの参照カウンタを加算する
        ページの参照カウンタ加算に失敗したらエラー復帰する
     6) ページの状態がValidかつDirtyでない(異常状態ではないことを確認する)
     7) ページの状態がInvalidだったらvfsオペレーションを呼び出してブロックの
        内容をページに読み込む
     8) ページの読み込みに失敗したら, v-nodeのmutexを獲得して、
        v-nodeのファイルページキャッシュツリーから登録を抹消し、
	v-nodeのmutexを解放,
	ページキャッシュの参照カウンタを減算して(登録を抹消)
	ページキャッシュを解放するエラー復帰ルートに飛ぶ(ページキャッシュ参照カウンタ減算)
     9) ページの状態をValidに遷移させる
    11) ページを返却する

2.. ページキャッシュ解放 (内部関数)
    1) ページキャッシュプールへの参照を減算
    2) ページキャッシュプールへのリンクを無効化
    3) ページを解放
    4) ページキャッシュを解放

2.. ページキャッシュ参照加算 (vfs内部関数)
    ページキャッシュの参照が1以上の場合は, 参照カウンタを加算
    参照カウンタの加算に成功したら真を, そうでない場合は偽を返却

2.. ページキャッシュ参照減算 (vfs内部関数)
    ページキャッシュの参照が1以上の場合は, 参照カウンタを減算
    参照カウンタが0になったら真を, そうでない場合は偽を返却

2.. ページキャッシュの状態をclean(二次記憶との一貫性がとれた状態)に設定する (内部関数)

2.. ページキャッシュの状態をdirty(二次記憶よりキャッシュの方が新しい状態)に設定する(内部関数)

2.. ページキャッシュDBへのブロックデバイスキャッシュの登録
2.. ページキャッシュDBからのブロックデバイスキャッシュの登録抹消
2.. ページキャッシュDBからブロックデバイスキャッシュの検索・参照取得

2.. ブロックデバイスキャッシュへのページキャッシュ登録
2.. ブロックデバイスキャッシュからのページキャッシュ登録抹消
2.. ブロックデバイスキャッシュからのページキャッシュ検索・参照取得
    ブロックデバイスキャッシュを指定してページキャッシュの検索・参照獲得を実施

2.. ブロックデバイスキャッシュ中のページキャッシュに二次記憶の内容を読みだし
2.. ブロックデバイスキャッシュ中のページキャッシュを二次記憶へ書き出し

2.. v-nodeのページキャッシュツリーへの登録
2.. v-nodeのページキャッシュツリーからの登録抹消
2.. v-nodeのページキャッシュツリーからの検索

2.. v-node初期化時のページキャッシュツリーの初期化
2.. v-node解放処理のページキャッシュ書き出し

2.. vfsのページI/O機構の初期化
大域変数としてページキャッシュキャッシュを宣言する
ページキャッシュ用のキャッシュを初期化する

2.. vfsのページI/O機構の終了

vfsレイヤでのread/writeシステムコールページ単位でのI/O処理:
(1) ページをv-nodeのページキャッシュツリーから検索する
(2) v-nodeのページキャッシュツリーからページが見つからなければ,
    ページキャッシュを割り当て, ページの内容をクリアする
    (ページの状態はInvalid)
(3) ページの状態がDirtyでなく, かつ, validでなく, かつ、
    マウントされているファイルシステム(疑似ファイルシステムでない)または
    v-nodeのマウント情報のdevidが無効デバイスでなければ、以下の(a)-(b)を実施する
    (a) ファイルシステムに依頼して, ファイル内オフセットを指定して、
        ページに二次記憶のブロックの割り当てを依頼する(fsオペレーション)
    (b) ファイルシステムのread_pageオペレーションが定義されていなければ
        ページリードの項目に記載している内容を実施する
        (read_page_from_block_device関数として定義する)
    (c) ページの状態をValid(clean)にする

(4) ページの状態がdirtyかvalidであることを確認する
    (dirty|valid)との論理積が0でなく、かつ、(dirty|valid)でないことを確認する

(5) ページをv-nodeのページキャッシュツリーに登録する
(6) devidが無効デバイスでなければ, ページをブロックデバイスキャッシュに登録する
(6) writeの場合は, ファイルシステムのwrite_pageオペレーションを呼び出す
(7) ページがBUSYでないことを確認
(8) ページがDIRTYの場合は, DIRTY LRUの, VALIDの場合は, CLEAN LRUの末尾に
    ページキャッシュを追加する
(6) (1)で得たページキャッシュへの参照を解放する

2.. ページに二次記憶のブロックを割り当てる (fsオペレーション)
    (1) i-nodeのブロックマップ情報に従ってマップ先ブロックを算出する
    (2) そのブロックのページアドレス(デバイスの先頭からページ単位で区切った際の
        連番)を算出する
    (3) (2)で得た値をページキャッシュのpc_bdev_offsetに設定する

2.. ページリード (fsオペレーション)
    (a) ページに対するリクエストキューを作成する
    (b) リクエストキューにページへの読み込み/書き込み種別と
        ページキャッシュの組からなるリクエストエントリを追加する
    (c) ブロックの内容をページに読み込むようブロックデバイスに要求する
        将来的には非同期リクエストを発行して, リクエストキューで休眠する
    デバイスドライバは以下のi), ii)を実行する
        i) ドライバはリクエストキュー中のリクエストを取り出して、
           ページをBUSY(ロック)状態にする
       ii)  デバイスへのI/Oリクエストを
	   ページをブロックに分割して、ブロック単位で発行する。
  	   ページの途中でエラーになったら対象のリクエストにエラーマークを設定する
       iii) ページのBUSY(ロック)状態を解除する
	iv) リクエストの最後までページを処理する
    	   (*) 非同期I/Oを想定して、リクエストエントリ, リクエストキューは動的に
	       メモリ獲得する。
        v) リクエストキュー中のをすべてのリクエストエントリを処理し終わったら,
           リクエストキューで休眠しているプロセスを起床する
    (d) リクエストキューを順番に取り出し、完了したリクエストエントリを解放
    (e) リクエストキューを解放
    (f) (d) でエラーリクエストがあった場合は, エラー復帰する

2.. ページライト (fsオペレーション)
2.. ページを二次記憶に書き戻す前準備を行う (fsオペレーション)
- ジャーナリングなど
