* アセンブラファイルのスタックフレームレイアウトの誤りを修正。
* 使用している関数の__unusedマクロを落とす
* ktestをマクロから関数に置き換える
* v-nodeロックをシステムコール実処理部に移動
* v-node/ページキャッシュを優先度継承付きオブジェクトにする
  - v-nodeを優先度継承付きオブジェクトにする
  - ページキャッシュを優先度継承付きオブジェクトにする
  - 優先度継承フラグをウエイトキューに設定する
  - v-node/ページキャッシュのウエイトキューを優先度継承付きに設定する
  - v-nodeロック時にオーナを自スレッドに設定し, アンロック時にオーナーを解放する

* getcwdシステムコールを追加
* v-nodeキャッシュの解放IFを追加(現状はunmount以外ではキャッシュを解放しない)
  処理内容 unmount_common(vnode *root_vnode)との共通化を図ること
      マウントテーブルをロック
      マウントポイント情報の参照獲得
        マウントポイント情報の参照が得られなかった場合は, マウントテーブルをアンロックして
	エラー復帰する
        マウントポイントが見つからなかった場合は, マウントテーブルをアンロックして
	エラー復帰する
      ボリューム中のv-nodeを書き出し,v-nodeをロックする(sync_and_lock_vnodes)
      共通化する場合は, sync_and_lock_vnodesでアンマウント中に遷移させないようにする
      アンマウント処理の場合は, アンマウント中に遷移させる必要があるが, 遷移時にマウントポイント
      ロックをとっていなければならない
      =>sync_and_lock_vnodesのマウントポイントロック獲得処理を外に出すか
        アンマウント遷移指示オプションを追加する
      アンマウント処理中の場合は, ファイルシステム固有なアンマウント処理を実施
      root v-node以外のv-nodeを解放(free_vnodes_in_fs_mount)
      アンマウント処理中の場合は, root v-nodeの参照を解放する
      アンマウント処理中の場合は, ルートマウントでない場合は,
	  マウントポイントv-nodeからの参照を除去
	  マウントポイントディレクトリのv-nodeへの参照を解放する
	  マウントポイントv-nodeを無効化
      マウント情報の登録を抹消
      マウントテーブルをアンロック
      マウントポイントの参照解放
      正常終了
      マウント参照解放エラー復帰
	マウントテーブルをアンロック
	マウントポイントの参照解放
      エラー復帰
        エラーコードを返却して復帰

* mutex_lockでエラーチェックをしていないものがある
* v-nodeにページキャッシュ機構を追加(VFSレイヤのページキャッシュ)
  以下のオペレーションをvfsオペレーションに追加
  - prepare_write(ページをブロックにマッピング=ブロックページキャッシュの割り当て)

  - write(VFSページキャッシュの更新)
  - commit_write(ページを2次記憶に書き出し)
  - read(VFSページキャッシュからの読み込み)[済み]

* vfsオペレーションにアクセス権チェックを追加

* 可変長のIDビットマップ機構を導入し, VFSの上限制限を撤廃
* ツールにchdir/mkdir/mknodを追加
* プロセスヒープの伸縮処理を追加
* スレッド終了処理で全てのメンバが解放されていることをレビューで確認
* プロセス内のすべてのスレッドに対する操作を行うマクロを追加
* MachVMのvm_map インターフェースのサブセットを実装
  vm_map_create
  vm_map_delete
  vm_map_entry_link
  vm_map_entry_unlink
  vm_map_find
  vm_map_findspace
  vm_map_init
  vm_map_insert(fileマップ用に別関数にしてもよい)
  vm_map_lock, vm_map_trylock, vm_map_unlock
  vm_map_check_protection
  vm_map_lookup, vm_map_lookup_done
  vm_map_protect
  vm_map_remove
  vm_map_stack
  vm_map_growstack

* mutexに優先度継承機能を追加(データ構造の初期化のみは実施)
* wqueue.cでデータ構造からの参照を管理していない
  ウエイトする際にスレッドオーナリンクやウエイトキューからの参照を増やして
  ウエイトキューから外れた際にウエイトキューからの参照を減算する
  ロックを解放した時点でスレッドオーナリンクからの参照を解放する
* フィードバックスケジューラ(4.4BSDスケジューラ機能)を実装

* ページキャッシュ機構を再設計[済み]
* BIOリクエストエントリ処理中でロックをとること[済み]
* ブロック(ブロックデバイスページキャッシュ)のインバリデート処理を追加し,
  ブロックサイズ変更時にブロックバッファがインバリデートされるようにすること[済み]
* 削除予約済みv-nodeがget_vnodeされないようにmountテーブルから外すこと[済み]
* uid/gidをクレデンシャル構造体に移動[済み]
* 未使用IFであるvfs_vnode_put/vfs_vnode_removeのテストまたは削除[削除済み]
* vfsにchdir/chrootを追加[済み]
* ディレクトリかどうかの判定はvnode->v_modeを使用して実施[済み]
* ファイル・ディレクトリのread/writeを伴うオペレーションでvnode lockをとるように修正[済み]
  - vnodeロックをとっていないところに理由を記載する[済み]
  a) v-node releaseはv-node解放時なので競合となるスレッドがいない
  b) fdのreleaseは, ファイルの属性更新やファイルのデータ参照・更新を行わない
     (ファイルディスクリプタプライベート情報の解放), 依存する場合はv-node releaseで処理する
  c) read/writeは, システムコール処理部でロックを獲得・解放する
     システムコール処理部でメモリマッピングを解析しながらページ単位で
     読み書きしながらシステムコールで指定されたread/write長を満たすかエラーになるまで
     v-nodeロックを保持し続けなければならない
  d) vfs_getattr/vfs_setattrは, read/writeやディレクトリエントリ操作に伴う属性確認や
     時刻更新処理から呼ばれるためこれらの関数内ではv-nodeロックをとらない。
  e) v-nodeロックを自スレッドが保持していることを確認するassertを追加する.
     v-nodeロックを自スレッドが保持していることを記録する処理は, v-nodeのBUSYビットを立てる
     ところで行う(vnode_lock以外にBUSYビットを立てるところがあるので)
     v-nodeのBUSYビットを立てる/落とす関数を新設する
* ファイル/ディレクトリ作成時についてのメモ [済み]
  ファイル作成先のディレクトリに名前とinode(ディレクトリエントリ)作成する
  新規作成したファイルのnlinkを1にする。
  新規作成したファイルが, ディレクトリだった場合は, 作成したinode(作成対象のディレクトリ)の
  nlinkを+1
  (作成したディレクトリのnlinkは2になる), 親ディレクトリのnlinkを+1する
* mount/unmount/fd+ioctxの全ルートテストを実施
  (未使用IFであるvfs_vnode_put/vfs_vnode_removeを除く) [済み]
* 基本的なシステムコール<=>vfs間IFを実装[済み]
  - vfs_openのレビュールートテスト[済み]
    - 参照カウンタの一貫性[済み]
    - 多重ロック整合性確認[済み]
  - root fsマウント/通常マウント/通常アンマウント/root fsアンマウントのテスト[済み]
  - ファイルディスクリプタ未クローズ時のアンマウント失敗エラールートテスト[済み]
* rename処理でデッドロックを引き起こさないようにディレクトリエントリのv-nodeロックを
    v-node ID順に行うようにすること[済み]
* I-node時刻更新, リードオンリーファイルシステムチェックを入れる[済み]
* openしてクローズしていないファイルディスクリプタがある状態でiotctxを破棄してもsegvにならないことを確認する[済み]
  - ファイルを未クローズの時にunmountが走行するとv-nodeが解放されて
    ファイルディスクリプタから解放済みのv-nodeが参照されたままになり
    不正メモリアクセスになる問題を修正すること[済み]
    =>原因は, ファイル削除後v-node参照カウンタが, fdから参照されているのか
      mountから参照されているのかunmount_common実行時に判定できないこと
      * クローズせずfdtblに残っているfd内のv->v_refsは2になっている
      * この状態umountすると以下の判定でエラーになるのでマウントさせずに失敗させる
		if ( ( check_vnode_flags_nolock(v, VFS_VFLAGS_BUSY) ) ||
		     ( (v != mount->m_root) && ( refcnt_read(&v->v_refs) > 1 ) ) || (★)
		     ( (v == mount->m_root) && ( refcnt_read(&v->v_refs) > 3 ) ) ) {

			     /* root v-node でない場合で参照中の場合または
			      * root v-node の場合で参照数が3より大きい場合は,
			      * エラー復帰する
      * その後unlinkすると, v->v_refsは減算され1になる
      * この状態でunmountすると, unmount_common実行時にv-nodeの解放が行われるので
        ファイルディスクリプタf->f_vnはNULLにならないが, 実際のv-nodeは解放済みになる
        これは, unmount_commonが上記のv-nodeの参照数1がマウント情報からの参照と
	ファイルディスクリプタからの参照のいずれによるものであるかを判断できないため
        本来, ファイルディスクリプタからの参照か, マウント情報/スレッドからの参照の
        いずれかの参照がある場合は, アンマウントをエラーにするのが正しい。
      修正策は
        1) v-node解放時にファイルディスクリプタからの参照をクリアするか
        (複数fdから同一のvnを参照しうるので単純ではない)
        2) ファイルディスクリプタから参照数をカウントするためのカウンタをv-nodeに新設するか
      基本は2)と考える. この時のファイルディスクリプタから参照数をカウントするためのカウンタは
      アトミックカウンタではなく通常の整数(オブジェクト数)で,
      v-nodeのmutexを保持して参照・更新する(ファイルディスクリプタ制御はタスクコンテキストなので
      mutexによる排他, アンマウント時にunmount_commonでv-nodeのmutexを保持してカウント数を確認
      する内部仕様であるため。
* read/writeのfile_privateの位置が異なるので修正[済み]
* RB_TREEの比較関数の仕様を確認して修正(大小関係が逆になっているものがある) [澄み]
* アンマウント時にmount->m_root(マウントポイントのv-node)の参照が0になり,
  root v-nodeとマウントポイントの双方が正しく解放されること(root v-nodeの解放に伴って
  マウントポイントの参照数が0になること)を確認する。[済み]
  =>rootマウント時, 通常のマウント時ともにroot v-node, マウントポイントともに解放されることを
  デバッガで追跡して確認した。
* 物理ファイルシステム層でvfs_*型が直接見えるのはおかしいので修正する[済み]
* simplefs_inode_truncate_downを他のファイルシステムと同構成にする[済み]

* mutex/waitキュー操作を実装[済み]
  - スレッド管理実装後にTODOを消化し, mutexのテストを追加する
* vfs_mountをファイルシステムツリーをたどってファイルシステムを自動認識するIFにし,
  ファイルシステム名付きでマウントするIFの名称をvfs_mount_with_fsnameに名称変更[済み]
* ファイルモードの獲得をfs_vnode_lookupからfs_getvnodeに移動[済み]
* グローバルrootアンマウント処理を追加[済み]
* v-nodeの参照制御の修正[済み]
  - 参照をgetで加算/putで減算する[済み]
    生成時に設定した参照をget/putで失わないようにしキャッシュとして動作できるようにするため
  - マウント/アンマウント時の参照カウンタ条件(assert)を合わせること[済み]
* vflagsのフラグ操作関数に引数を追加し, フラグのセット・アンセット・チェック処理を共通化[済み]
* mnt_id/vnode_id/ioctx_idにvfs_プレフィックスをつける[済み]
* minixのディスクI-nodeからスーパブロック情報を参照している箇所を引数でスーパブロック情報
  を引き渡すように修正[済み]
* unmap_zoneでinode中のゾーン割り当てを解放する[済み]
  (free_zoneを呼ぶ代わりにそのゾーンへのマップを消去する処理を呼び出す)
* minix_inode_rwをminix_rw_datazoneに名称変更[済み]
* I-node情報のアクセスタイムメンバ更新マクロを作成[済み]
  - atime/mtime/ctimeは別マクロにする[済み]
* スレッド処理の各関数で参照数制御が合うことをレビューで確認[済み]
* カーネルスレッド生成共通処理を追加[済み]
  - カーネルスレッド生成処理を追加 [済み]
  - 既存のスレッドテストをカーネルスレッド生成処理に変更[済み]
  - ユーザスレッド生成処理にはプロセス管理情報を引き渡すように修正[済み]
  - カーネルスレッド生成処理ではカーネルのプロセス管理情報を引き渡す[済み]
  - 引数(argc, argv, environment)を扱えるようにする[済み]
    -- 共通処理のIFを修正(引数のアドレスを追加)[済み]
    -- argc, argv, environmentをスタック上に用意する[済み]
    -- argcの直下に配列領域を用意, ポインタ配列(argv[], environment[])の各要素を設定する[済み]
* プロセスIDにページテーブルのアドレス空間IDを使用するように修正[済み]
  - ASID型, ASID最大値をHALに定義[済み]
  - kern/vm-pgtbl.cでASIDを割当て/解放する[済み]
* スレッド生成処理時にプリエンプションカウンタがクリアされる問題を修正[済み]
  - スレッド情報初期化処理を独立化[済み]
  - スレッド生成共通処理からスレッド情報初期化処理を除去[済み]
  - スレッド生成共通処理に親スレッドへの子スレッド追加処理を追加[済み]
* スレッド終了処理で子スレッド解放処理を追加[済み]
* 論理プロセッサID 0を即値で記載しているところをマクロに置き換える[済み]
* プロセス管理情報の参照制御を追加[済み]
* ユーザページテーブルアロケート[済み]
  - カーネルVPN2のコピー[済み]
* ユーザページテーブルデアロケート[済み]
* hal_copy_kernel_pgtblから呼び出し元にロック獲得位置を変更[済み]
* atomic_add_fetch/atomic_sub_fetchを統計情報カウンタに置き換え[済み]
* カーネルエントリ時にベクタをカーネルベクタに設定[済み]
* ユーザページマップ関数[済み]
* ユーザページコピー関数[済み]
  - extract mapしてマップ先ページアドレスとサイズ、属性を得る
  - マネージドページについて同サイズでページを獲得
  - 同一仮想アドレスにマップ
* CPUのオフライン制御

* 割り込み管理共通部[済み]
* 割り込みコントローラ処理部[済み]
  - Platform-Level Interrupt Controller PLIC[済み]
  - Core-Local Interrupt Controller CLIC[済み]
    https://github.com/riscv/riscv-fast-interrupt/blob/master/clic.adoc
* タイマ有効化/シリアル割り込み確認[済み]
* コールアウトキューを時刻管理情報に移動しロック構成を単純化[済み]
* タイマ管理[済み]
  - ブート時のMTIME(システム時刻0のときのMTIME値)をmscratch情報に保存するように修正。
  - ティックレス
    a) 次回のタイマプログラム時の時刻(次のタイマ割込み発生時刻のMTIME-ブート時のMTIME)を
    b) タイムスペックに換算(us=>timespec)し, 次回のタイマプログラム時の時刻をtimespecで求める
    c)  未処理のハンドラで最も直近のものからtimespecを取得しb)+レイテンシよりも大きい
        最初のエントリを得る
    d) で得たtimespecをmtimeに変換 = timespecのマイクロ秒換算値
    e) で得た値から次回のタイマ時刻を減算した値をtimer_interval_cycに代入

* プロセス管理部(カーネルプロセス)
  - プロセス管理情報の割当て(proc_allocate)
  - プロセス管理情報の解放(proc_free)
  - プロセスへの空間操作
     -- 空間の生成
     -- 空間の解放
     -- 空間の属性変更
     -- 空間を分離
     -- 空間の一部を削除
     -- 空間を結合

* スレッド管理部
  - 優先度継承中にプライオリティを変更するために
    初期化時優先度
    ベース優先度
    実効優先度
    の3つを定義, プライオリティの変更はベース優先度に対して行う
  - スレッド参照処理

* スレッドタイマ(ラウンドロビン)
* プロセス管理部(ユーザプロセス)
* ELF
* テスト1回目(システムコールはデバッグ文字列出力のみ

* fileディスクリプタ管理
* ページキャッシュ管理[済み]
  - ページキャッシュ管理基本部[済み]
  - LRUサポート[済み]
* bdevレイヤでのページキャッシュ<->FSイメージのバッファコピー[済み]
* マウント管理
* vnodeキャッシュ管理
* minixfs
* デバイスIF
* 端末キュー
* init
* shell

* テスト2回目プロセスロード
