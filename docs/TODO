* スレッド生成処理時にプリエンプションカウンタがクリアされる問題を修正。
  スレッド情報初期化処理を独立化
  スレッド生成共通処理からスレッド情報初期化処理を除去

* プロセス内のすべてのスレッドに対する操作を行うマクロを追加
* スレッド終了処理で全てのメンバが解放されていることをレビューで確認
* スレッド処理の各関数で参照数制御が合うことをレビューで確認

* プロセス管理情報の参照制御を追加[済み]
* mutex/waitキュー操作を実装
  - スレッド管理実装後にTODOを消化し, mutexのテストを追加する
* ユーザページテーブルアロケート[済み]
  - カーネルVPN2のコピー[済み]
* ユーザページテーブルデアロケート[済み]
* hal_copy_kernel_pgtblから呼び出し元にロック獲得位置を変更[済み]
* atomic_add_fetch/atomic_sub_fetchを統計情報カウンタに置き換え[済み]
* カーネルエントリ時にベクタをカーネルベクタに設定[済み]
* ユーザページマップ関数[済み]
* ユーザページコピー関数[済み]
  - extract mapしてマップ先ページアドレスとサイズ、属性を得る
  - マネージドページについて同サイズでページを獲得
  - 同一仮想アドレスにマップ
* CPUのオフライン制御

* 割り込み管理共通部[済み]
* 割り込みコントローラ処理部[済み]
  - Platform-Level Interrupt Controller PLIC[済み]
  - Core-Local Interrupt Controller CLIC[済み]
    https://github.com/riscv/riscv-fast-interrupt/blob/master/clic.adoc
* タイマ有効化/シリアル割り込み確認[済み]
* コールアウトキューを時刻管理情報に移動しロック構成を単純化[済み]
* タイマ管理[済み]
  - ブート時のMTIME(システム時刻0のときのMTIME値)をmscratch情報に保存するように修正。
  - ティックレス
    a) 次回のタイマプログラム時の時刻(次のタイマ割込み発生時刻のMTIME-ブート時のMTIME)を
    b) タイムスペックに換算(us=>timespec)し, 次回のタイマプログラム時の時刻をtimespecで求める
    c)  未処理のハンドラで最も直近のものからtimespecを取得しb)+レイテンシよりも大きい
        最初のエントリを得る
    d) で得たtimespecをmtimeに変換 = timespecのマイクロ秒換算値 
    e) で得た値から次回のタイマ時刻を減算した値をtimer_interval_cycに代入

* プロセス管理部(カーネルプロセス)
  - プロセス管理情報の割当て(proc_allocate)
  - プロセス管理情報の解放(proc_free)
  - プロセスへの空間操作
     -- 空間の生成
     -- 空間の解放
     -- 空間の属性変更
     -- 空間を分離
     -- 空間の一部を削除
     -- 空間を結合

* スレッド管理部
  - 優先度継承中にプライオリティを変更するために
    初期化時優先度
    ベース優先度
    実効優先度
    の3つを定義, プライオリティの変更はベース優先度に対して行う
  - スレッド参照処理

* スレッドタイマ(ラウンドロビン)
* プロセス管理部(ユーザプロセス)
* ELF
* テスト1回目(システムコールはデバッグ文字列出力のみ

* fileディスクリプタ管理
* ページキャッシュ管理[済み]
  - ページキャッシュ管理基本部[済み]
  - LRUサポート[済み]
* bdevレイヤでのページキャッシュ<->FSイメージのバッファコピー[済み]
* マウント管理
* vnodeキャッシュ管理
* minixfs
* デバイスIF
* 端末キュー
* init
* shell

* テスト2回目プロセスロード
