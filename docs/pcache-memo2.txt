[1] データ構造

/*
 * ページキャッシュの状態
 */
#define	PCACHE_INVALID           (0x0)    /**< 無効なキャッシュ                         */
#define	PCACHE_BUSY              (0x1)    /**< ページキャッシュがロックされている       */
#define	PCACHE_CLEAN             (0x2)    /**< ディスクとキャッシュの内容が一致している */
#define	PCACHE_DIRTY             (0x4)    /**< ページキャッシュの方がディスクより新しい */

/*
 * ページキャッシュプールの状態
 */
#define	PCPOOL_DORMANT           (0x0)    /**< 無効なページキャッシュプール             */
#define	PCPOOL_CREATED           (0x1)    /**< 有効なページキャッシュプール             */
#define	PCPOOL_DELETE            (0x2)    /**< 削除予約されている                       */

typedef uint32_t      vfs_pcache_state;   /**< ページキャッシュの状態                   */
typedef uint32_t vfs_pcache_pool_state; /**< ページキャッシュプールの状態 */

struct _bdev_entry;
/**
   ページキャッシュ
 */
typedef struct _vfs_page_cache{
	/** ページキャッシュデータ構造更新ロック */
	spinlock                         pc_lock;
	/** 排他用ロック(状態/ページ更新用)      */
	struct _mutex                     pc_mtx;
	/** 参照カウンタ                         */
	refcounter                       pc_refs;
	/** ページキャッシュプールへのリンク     */
	struct _vfs_page_cache_pool  *pc_pcplink;
	/** バッファの状態                       */
	pcache_state                    pc_state;
	/** パディング                           */
	uint32_t                            pad1;
	/** ページバッファ待ちキュー             */
	struct _wque_waitqueue        pc_waiters;
	/** ファイル/ブロックデバイス中のオフセットをキーとした検索用RB木エントリ        */
	RB_ENTRY(_vfs_page_cache)         pc_ent;
	/** ファイル中でのオフセットアドレス (単位:バイト)                               */
	off_t                          pc_offset;
	/** LRUリストのエントリ                                                          */
	struct _list                 pc_lru_link;
	/** ページフレーム情報                   */
	struct _page_frame                *pc_pf;
	/** ページキャッシュデータへのポインタ   */
	void                            *pc_data;
}vfs_page_cache;

/**
   ページキャッシュプール
 */
typedef struct _vfs_page_cache_pool{
	/** 排他用ロック(キュー更新用) */
	struct _mutex                                    pcp_mtx;
	/** 参照カウンタ               */
	refcounter                                      pcp_refs;
	/** ページキャッシュプールの状態 */
        vfs_pcache_pool_state                          pcp_state;
	/** ブロックデバイス         */
	struct _bdev_entry                             *pcp_bdev;
	/** ファイルのv-node           */
	struct _vnode                                 *pcp_vnode;
	/**  ページサイズ              */
	size_t                                         pcp_pgsiz;
	/**  ページキャッシュツリー    */
	RB_HEAD(_pcache_tree, _vfs_page_cache)          pcp_head;
	/**  LRUキャッシュ (二次記憶との一貫性がとれているページ)     */
	struct _queue                              pcp_clean_lru;
	/**  LRUキャッシュ (二次記憶よりキャッシュの方が新しいページ) */
	struct _queue                              pcp_dirty_lru;
}vfs_page_cache_pool;

/**
   ページキャッシュプールDB(デバイスIDをキーにデバイスのページキャッシュプールを検索する)
 */
typedef struct _vfs_page_cache_pool_db{
	/** ページキャッシュプールDBのロック */
	spinlock                         lock;
	/** ページキャッシュプールDB         */
	RB_HEAD(_page_cache_pool_tree, _page_cache_pool) head;
}vfs_page_cache_pool_db;

/**
   ページキャッシュプールDB初期化子
   @param[in] _pcpdb ページキャッシュプールDBのアドレス
 */
#define __PCPDB_INITIALIZER(_pcpdb) {		                            \
	.lock = __SPINLOCK_INITIALIZER,		                            \
	.head  = RB_INITIALIZER(&((_pcpdb)->head)),		            \
	}


1.2. 参照管理
1.2.1. ページキャッシュ

1.2.2. ページキャッシュプール

[2] ページキャッシュインターフェース

2.1. bool vfs_page_cache_ref_inc(struct _vfs_page_cache *_pc);
     ページキャッシュへの参照を得る
2.2. bool vfs_page_cache_ref_dec(struct _vfs_page_cache *_pc);
     ページキャッシュへの参照を解放する
2.3. int vfs_page_cache_mark_clean(struct _vfs_page_cache *_pc);
     ページキャッシュを同期済みに設定する
2.4. int vfs_page_cache_mark_dirty(struct _vfs_page_cache *_pc);
     ページキャッシュを更新済みに設定する
2.5. int vfs_page_cache_pagesize_get(struct _vfs_page_cache *_pc, size_t *_sizep);
     ページキャッシュのページサイズを獲得する
2.6. int vfs_page_cache_refer_data(struct _vfs_page_cache *_pc, void **_datap);
     ページキャッシュのデータ部のアドレスを得る



int vfs_page_cache_refer_data(struct _vfs_page_cache *_pc, void **_datap);

int vfs_page_cache_enqueue_block_buffer(struct _vfs_page_cache *_pc,
    struct _block_buffer *_buf);
void vfs_page_cache_block_buffer_unmap(struct _vfs_page_cache *_pc);
int vfs_page_cache_block_buffer_find(struct _vfs_page_cache *_pc, size_t _offset,
    struct _block_buffer **_bufp);

bool vfs_page_cache_pool_ref_inc(struct _vfs_page_cache_pool *_pool);
bool vfs_page_cache_pool_ref_dec(struct _vfs_page_cache_pool *_pool);
int vfs_page_cache_pool_shrink(struct _vfs_page_cache_pool *_pool,
    singned_cnt_type _reclaim_nr, singned_cnt_type *_reclaimedp);
int vfs_page_cache_pool_pagesize_get(struct _vfs_page_cache_pool *_pool, size_t *_pagesizep);

int vfs_page_cache_invalidate(struct _vfs_page_cache *_pc);
int vfs_page_cache_get(struct _vfs_page_cache_pool *_pool, off_t _offset,
    struct _vfs_page_cache **_pcp);
int vfs_page_cache_put(struct _vfs_page_cache *_pc);
int vfs_page_cache_rw(struct _vfs_page_cache *_pc);


2.7. int vfs_page_cache_devid_get(struct _vfs_page_cache *_pc, dev_id *_devidp);
